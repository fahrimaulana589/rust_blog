# Project Rules and Standards

## Language Preference
- **Language**: Indonesian (Bahasa Indonesia) - Always reply in Indonesian unless explicitly asked otherwise.


## Tech Stack
- **Language**: Rust (Edition 2024)
- **Framework**: Actix Web 4
- **Database**: SQLite
- **ORM**: Diesel 2.2 with r2d2 connection pooling
- **Validation**: validator 0.20
- **Serialization**: serde 1.0
- **Async Runtime**: Tokio (via Actix)

## Architecture
The project follows a strict **Clean Architecture** pattern suitable for Rust web services.

### Directory Structure
```
src/
  app/
    features/
      [feature_name]/
        interface/       # Controllers, DTOs, Presenters
        application/     # Use Cases (Business Logic)
        domain/          # Entities, Repository Traits
        infrastructure/  # Repository Implementations
    drivers/             # Framework drivers (routes, middlewares)
  utils/                 # Shared utilities (DI container, error handling)
  config/                # App configuration
  schema.rs              # Diesel schema
```

### Layer Responsibilities

1. **Interface Layer (`interface/`)**
   - **Controllers**: Handle HTTP requests, validate input, call Use Cases, and return Responses.
   - **DTOs**: Define data ownership for Requests (`...RequestDto`) and Responses (`...ResponseDto`).
   - **Validation**: Explicitly trigger `.validate()` on DTOs.
   - **Response**: Use `impl Responder`. Map success with `crate::utils::success_response` and errors with `crate::utils::error_response`.
   - **Pagination**:
     - All list endpoints **MUST** be paginated (Default: `page=1`, `per_page=10`).
     - Request: Use `PaginationRequestDto`.
     - Response: Use `PaginatedResponseDto<T>` wrapping items and metadata (`meta`).
     - Repository: Must accept `limit` and `offset` and return `(items, total_count)`.
   - **Update Operations (Partial Updates)**:
     - **DTOs**: Use `Option<T>` for all updatable fields to support partial updates.
     - **Semantics**:
       - `None` (missing field/null): Preserve existing value.
       - `Some(value)`: Update to new value.
       - `Some("")` (empty string): Trigger validation error if field is required (e.g., `#[validate(length(min=1))]`).
     - **Implementation**: In UseCase, merge existing entity with provided `Some` values: `dto.field.unwrap_or(existing.field)`.

2. **Application Layer (`application/`)**
   - **Use Cases**: Contains business logic.
   - **Grouping**:
     - **Multiple Entities**: If a feature manages multiple entities (e.g., Blog has Category, Tag), create separate modules named `[entity]_usecase` (e.g., `application/category_usecase/`).
     - **Single Entity/Simple**: If the feature is simple (e.g., Auth), a flat `application/usecase/` structure is acceptable.
   - **Structure**: Each Use Case is a struct named `Execute` (or specific name if needed) with a `new` constructor and an `execute` async method.
   - **Input**: Accepts Request DTOs (e.g., `CreateCategoryRequestDto`) or primitive types.
   - **Output**: Returns `Result<T, String>`.
   - **Dependencies**: Injects Repository Traits.

3. **Domain Layer (`domain/`)**
   - **Entities**: Diesel structs (`Queryable`, `Insertable`, etc.). make fields `pub`.
   - **Repositories**: Traits defining database operations. Methods return `diesel::QueryResult`.

4. **Infrastructure Layer (`infrastructure/`)**
   - **Repository Implementation**: Implements Domain Repository Traits using Diesel DSL.
   - **Database Access**: Uses `DbPool` injected in constructor.

## Naming Conventions
- **Feature Modules**: `snake_case` (e.g., `blog`, `auth`).
- **DTOs**:
    - Request: `[Action][Entity]RequestDto` (e.g., `CreateCategoryRequestDto`)
    - Response: `[Entity]ResponseDto` (e.g., `CategoryResponseDto`)
- **Use Cases**:
    - Complex: `[entity]_usecase::[action]::Execute` (e.g., `category_usecase::create::Execute`).
    - Simple: `usecase::[action]::Execute`.
- **Repositories**:
    - Trait: `[Entity]Repository` (e.g., `BlogRepository`)
    - Impl: `[Entity]RepositoryImpl` (e.g., `BlogRepositoryImpl`)

## Coding Standards

### Error Handling
- **Repositories**: Return `QueryResult<T>`. Do not verify logic here, just DB ops.
- **Use Cases**: Return `Result<T, String>`. Map DB errors to `String` using `.map_err(|e| e.to_string())`.
- **Controllers**:
    - Validation Errors: `HttpResponse::BadRequest().json(map_validation_error(e))`
    - Logic/System Errors: `HttpResponse::InternalServerError().json(map_string_error(e))`
    - Not Found: Check error string content (e.g., `if e.contains("not found")`) and return `NotFound`.

### Dependency Injection
- Manual DI via `crate::utils::di::Container` struct.
- Register new Use Cases in `Container` struct.
- Initialize them in `Container::new()`.
- Inject `web::Data<Container>` into Controllers.

### Routing
- Register services in `src/app/drivers/routes.rs`.
- Group feature routes appropriately (e.g., under `/app` scope).

## Workflow for New Features
1.  **Domain**: Define Entities and Repository Trait.
2.  **Infrastructure**: Implement Repository Trait.
3.  **Interface**: Define Request/Response DTOs with Validation.
4.  **Application**: Implement Use Cases using Repository Trait.
5.  **Interface**: Implement Controller to wire DTOs and Use Cases.
6.  **Wiring**: Add to `Container` in `di.rs` and `routes.rs`.
7.  **Testing**: Implement Integration Tests in `src/test/` ensuring coverage.

## Testing Standards (MANDATORY)

### 1. Test Categories & Location
- **Unit Tests**:
    - **Location**: Inside the source file being tested, in a `mod tests` module annotated with `#[cfg(test)]`.
    - **Scope**: Individual functions, pure business logic, or complex algorithms without DB access.
- **Integration Tests**:
    - **Location**: Strictly in the `src/test/` directory.
    - **Scope**: Full API endpoint testing (Controller -> UseCase -> DB).
    - **File Structure**: One file per feature (e.g., `src/test/auth.rs`, `src/test/category.rs`).

### 2. Naming Conventions
- **Test Functions**: Must use `snake_case` and follow the pattern: `test_[action]_[entity]_[scenario]`.
    - **Positive Case**: `test_create_category_success`
    - **Negative Case**: `test_login_invalid_credentials`
    - **Edge Case**: `test_get_all_blogs_empty_list`
- **Variables**:
    - Use `_req` for unused request variables to avoid compiler warnings.
    - Use descriptive names: `create_dto`, `token`, `response_body`.

### 3. Integration Test Implementation Rules
- **Initialization**: You **MUST** use the `init_test_app!` macro. Import with `use crate::init_test_app;`.
- **Concurrency (VITAL)**:
    - **Problem**: SQLite is file-based and locks during parallel access.
    - **Solution**: Every integration test **MUST** be annotated with `#[serial]` from the `serial_test` crate.
    - **Syntax**:
      ```rust
      use serial_test::serial;
      #[actix_web::test]
      #[serial]
      async fn test_create_category_success() { ... }
      ```
- **Helpers**: Use `src/test/helpers.rs` for shared implementations (`seed_user`, `login_admin`).
- **Data flows**:
    - **Request**: Construct using DTOs defined in `interface/dto.rs`.
    - **Response**: Parse into `SuccessResponse<T>` to validate both the wrapper and the data.
    - **Coverage Requirements**:
    - **Happy Path**: Verify 200/201 status and correct data return.
    - **Error Path**: Verify 400/401/404/500 statuses for invalid inputs or states.
    - **Persistence**: Verify database state changes (e.g., fetch by ID after create).
    - **Pagination**: Verify `items` and `meta` fields in list responses.
- **Test Data Integrity**:
    - **Uniqueness**: Append unique identifiers (e.g., `chrono::Utc::now().timestamp_micros()`) to fields with unique constraints (names, titles) to prevent "Duplicate entry" errors.
    - **List Verification**: When verifying a created item is in a list, request a large page size (e.g., `?per_page=1000`) to ensure the item is retrieved regardless of database state.
- **One Test Per Path (MANDATORY)**:
    - You **MUST** write a separate, isolated test function for **EACH** public API endpoint/path (e.g., `test_create_project`, `test_get_project`, `test_update_project`).
    - Do **NOT** combine multiple distinct operations (like Create + Update + Delete) into a single test unless it is a specific **Flow Test** (see below).
    - Each test should set up its own data (seed) and verify its specific logic independently.

### 4. Schema Adherence (STRICT)
- **Goal**: Ensure tests validate the API contract and catch schema regressions.
- **Rule**: Tests **MUST** use the exact DTO types defined in the Interface Layer.
- **Requests**:
    - **FORBIDDEN**: Constructing ad-hoc JSON (e.g., `json!({"name": "foo"})`).
    - **REQUIRED**: Instantiate the Request DTO struct (e.g., `CreateCategoryRequestDto { name: "foo".to_string() }`).
- **Responses**:
    - **FORBIDDEN**: Parsing into generic `serde_json::Value`.
    - **REQUIRED**: Parse into the concrete Response DTO (e.g., `SuccessResponse<CategoryResponseDto>`).
    - **Assertions**: Perform assertions on the specific fields of the deserialized DTO (e.g., `assert_eq!(resp.data.unwrap().name, "expected")`).

### 5. Flow & Scenario Testing (MANDATORY)
- **Goal**: Verify complete business processes where state persists across multiple requests.
- **Goal**: Verify complete business processes where state persists across multiple requests.
- **Requirement**: This is **ADDITIONAL** to the "One Test Per Path" rule. Use this ONLY for multi-step features where the output of one step is required for the next (e.g., tokens, state transitions).
- **Example: Forgot Password Flow**:
    - **Step 1**: User requests password reset (Verify response).
    - **Step 2**: User submits new password with token (Verify strict schema validation on input/output).
    - **Step 3**: User logs in with `new_password` (Verify login success and token retrieval).
- **State Validation**: You **MUST** ensure that the output/side-effect of Step N (e.g., a generated token or DB change) is the direct input or precondition for Step N+1. Use the actual data returned by the API where possible.

## OpenAPI / Swagger UI Standards (MANDATORY)

### 1. Library & Configuration
- **Library**: `utoipa` and `utoipa-swagger-ui`.
- **Definition**: The central `ApiDoc` struct is located in `src/app/drivers/openapi.rs`.
- **Derive**: `#[derive(OpenApi)]` should appear ONLY on `ApiDoc`.

### 2. DTOs
- **Trait**: All Request and Response DTOs **MUST** derive `ToSchema`.
- **Location**: `interface/dto.rs` files.
- **Generic Types**: If a DTO is generic (like `PaginatedResponseDto<T>`), ensure `T` also implements `ToSchema`.

### 3. Controllers
- **Annotation**: Every public endpoint function **MUST** be annotated with `#[utoipa::path(...)]`.
- **Resolution**:
    - Use **Fully Qualified Paths** for types in `responses(...)` to avoid macro resolution failures (e.g., `body = crate::utils::success_response::SuccessResponse<crate::features::auth::dto::LoginResponseDto>`).
    - **Empty Responses**: Use `crate::utils::success_response::Empty` instead of `()` or `Option<()>` for `SuccessResponse` generics (e.g., `SuccessResponse<Empty>`). `utoipa` does not handle unit types well in generics.
- **Request Body**: Specify providing `request_body = DtoName`.
- **Responses**: Define at least `200` (Success), `400` (Bad Request/Validation), and `500` (Server Error).

### 4. Security
- **Scheme**: JWT Bearer Auth is configured globally.
- **Apply**: The `ApiDoc` struct must include `security(("jwt" = []))` in the `#[openapi(...)]` macro to enable the "Authorize" button globally.
- **Addon**: Security scheme details are defined in `SecurityAddon` struct in `openapi.rs`.

### 5. Access
- **Route**: Swagger UI is accessible at `/swagger-ui/`.
- **JSON**: The OpenAPI schema is served at `/api-docs/openapi.json`.
